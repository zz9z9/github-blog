---
title: 프로세스 간 통신 (IPC, Inter-Process Communication)
date: 2021-06-14 22:25:00 +0900
categories: [책으로 공부하기, 마이크로서비스 패턴]
tags: [Microservice Architecture]     # TAG names should always be lowercase
---
*※ 해당 내용은 '마이크로서비스 패턴(크리스 리처드슨)' 3장을 읽고 정리한 내용입니다.*

# Intro
---
- 마이크로서비스 아키텍처는 애플리케이션을 여러 서비스로 구성하며, 서비스 인스턴스는 여러 머신에서 실행되는 프로세스 형태이므로
반드시 IPC를 통해 상호작용 해야한다.
- IPC는 애플리케이션 가용성(정상적으로 사용가능한 정도)에 영향을 미치며, 트랜잭션 관리와도 맞물려 있다.

# IPC 개요
---
## 1. 통신 방식

|   | 일대일 | 일대다 |
|---|--------|--------|
|동기|  요청 / 응답 | - |
|비동기|비동기 요청 / 응답 <br> 단방향 알림 | 발행 / 구독 <br> 발행 / 비동기 응답 |

- `요청/응답`
  - 클라이언트는 응답이 제때 도착할 것을 기다리며 대기하는 동안 블로킹된다.
  - 서비스와 <u>강하게 결합</u>된다.
- `비동기 요청/응답`
  - 클라이언트는 서비스에 요청하고 서비스는 비동기적으로 응답.
  - 클라이언트는 응답에 대한 대기 중에 블로킹하지 않는다.
- `단방향 알림`
  - 클라이언트는 서비스에 요청을 하고 서비스는 응답을 보내지 않는다. **(어떤 경우 ??)**
- `발행/구독`
  - 클라이언트는 <u>알림 메시지</u>를 발행하고 여기에 관심 있는 0개 이상의 서비스가 메시지를 소비
- `발행/비동기 응답`
  -  클라이언트는 <u>요청 메시지</u>를 발행하고 주어진 시간 동안 관련 서비스가 응답하길 기다린다.

## 2. 메시지 포맷
- IPC의 핵심은 메시지 교환이며, 대부분의 메시지는 데이터를 담고 있기 때문에 데이터 포맷은 중요한 설계 결정 항목이다.
- 메시지 포맷은 크게 **텍스트**와 **이진 포맷**으로 분류된다.

### 텍스트 메시지 포맷
- 대표적인 예로 JSON, XML이 있다.
- 장점
  - 자기 서술적(그 자체만으로도 의미가 분명한)이다.
  - 메시지 컨슈머는 자신이 관심 있는 값만 골라 쓰면 되므로 스키마가 자주 바뀌어도 하위 호환성이 쉽게 보장된다.
- 단점
  - 메시지가 다소 길다 (특히, XML)
  - 속성값 이외에 속성명이 추가되는 오버헤드가 있다.
  - 데이터가 많은 메시지는 텍스트를 파싱하는 오버헤드가 있다.

### 이진 메시지 포맷 (???)
- 대표적으로 프로토콜 버퍼와 아브로가 있다.
- 메시지 구조 정의에 필요한 타입 IDL(Interface Definition Language)를 제공
- 컴파일러는 메시지를 직렬화/역직렬화하는 코드 생성
- 따라서, 서비스를 API 우선 접근 방식으로 설계할 수밖에 없다.

# 동기 RPI 패턴 응용 통신
---
- RPI(Remote Procedure Invocation)는 클라이언트가 서비스에 요청을 보내고 서비스가 처리 후 응답을 회신하는 IPC
- 응답 대기 중에 블로킹하는 클라이언트, 리액티브한 논블로킹 아키텍처를 가진 클라이언트도 있지만, 메시징으로 통신하는 클라이언트와 달리
응답이 제때 도착한다고 가정한다.
- RPI의 작동 원리
  - 클라이언트의 비즈니스 로직은 프록시 인터페이스 호출 (프록시 인터페이스는 RPI 프록시 어댑터 클래스로 구현)
  - RPI 프록시가 서비스에 전달한 요청은 RPI 서버 어댑터 클래스가 접수
  - 이 클래스는 서비스 인터페이스를 통해 비즈니스 로직 호출
  <figure align = "center">
    <img src = "https://thebook.io/img/007035/113.jpg" height="50%"/>
    <figcaption align="center">출처 : https://thebook.io/007035/ch03/02-01/</figcaption>
  </figure>

## 1. 동기 RPI 패턴 : REST
- HTTP 동사를 사용해서 URL로 참조되는 리소스를 조작
- REST API 설계시, 어떻게 최소한의 호출(요청)로 연관된 많은 객체들을 가져올 수 있을지 고민해야한다.
- 따라서 데이터를 효율적으로 조회할 수 있게 설계된 `GraphQL`, `Netflix Falcor`등의 기술이 각광을 받기 시작했다.
- 장점
  - API 자체가 단순하고, Postman, curl 등의 도구를 사용해서 테스트를 간편하게 할 수 있다.
  - HTTP는 방화벽 친화적<br>(방화벽 입장에서 쉽게 접근 가능한 특성을 지닌다 - 단일 포트 사용, 인터넷에서 서버 접속 가능, TCP 사용)
  - 중간 브로커가 필요하지 않기 때문에 시스템 아키텍처가 단순해진다.
- 단점
  - 시나리오가 복잡해질수록 효율이 떨어질 수 있다.
  - 요청/응답 스타일의 통신만 지원한다.
  - 클라이언트/서비스가 직접 통신하기 때문에 가용성이 떨어질 수 있다.(항상 양쪽 모두가 실행중이어야 하기 때문에)
  - 요청 한 번으로 여러 리소스를 가져오기 어렵다.
  - 다중 업데이트 작업을 HTTP 동사에 매핑하기 어려울 수 있다.

## 2. 동기 RPI 패턴 : gRPC
- gRPC는 구글에서 개발한 RPC(Remote Procedure Call) 시스템이다.
- HTTP는 한정된 동사만 지원하기 때문에 다양한 업데이트 작업을 지원하는 REST API를 설계하기가 쉽지 않다.<br>
바로 이러한 문제를 해결하고자 등장한 기술이 바로 `gRPC`이다.
- 장점
  - 다양한 업데이트 작업이 포함된 API를 설계하기 쉽다
  - 큰 메시지를 교환할 때 콤팩트하고 효율적이다
  - 양방향 스트리밍으로 인해 RPI, 메시징 두 가지 통신 방식이 모두 가능하다.
  - 다양한 언어로 작성된 클라이언트/서버 간 연동이 가능하다.
- 단점
  - 자바스크립트 클라이언트가 하는일이 REST/JSON 기반 API 보다 많다.
  - 구현 방화벽은 HTTP/2를 지원하지 않는다.

## 3. 부분 실패 처리 : 회로 차단기 패턴
## 4. 서비스 디스커버리


---

# 더 공부해야할 부분
- 이진 메세지 포맷
- gRPC

# 참고 자료
